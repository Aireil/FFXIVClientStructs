using System.Collections.Immutable;
using System.Diagnostics;
using InteropGenerator.Helpers;
using InteropGenerator.Models;

namespace InteropGenerator.Generator;

public sealed partial class InteropGenerator {
    private static string RenderStructInfo(StructInfo structInfo, CancellationToken token) {
        using IndentedTextWriter writer = new();
        // write file header
        writer.WriteLine("// <auto-generated/>");

        // write namespace 
        if (structInfo.Namespace.Length > 0) {
            writer.WriteLine($"namespace {structInfo.Namespace};");
            writer.WriteLine();
        }

        // write opening struct hierarchy in reverse order
        // note we do not need to specify the accessibility here since a partial declared with no accessibility uses the other partial
        for (int i = structInfo.Hierarchy.Length - 1; i >= 0; i--) {
            writer.WriteLine($"unsafe partial struct {structInfo.Hierarchy[i]}");
            writer.WriteLine("{");
            writer.IncreaseIndent();
        }

        // write addresses for resolver
        if (structInfo.HasSignatures()) {
            RenderAddresses(structInfo, writer);
            token.ThrowIfCancellationRequested();
        }

        if (structInfo.HasVirtualTable()) {
            RenderVirtualTable(structInfo, writer);
            token.ThrowIfCancellationRequested();
        }

        // write member function pointers & method bodies
        if (!structInfo.MemberFunctions.IsEmpty) {
            RenderMemberFunctions(structInfo, writer);
            token.ThrowIfCancellationRequested();
        }

        if (!structInfo.VirtualFunctions.IsEmpty) {
            RenderVirtualFunctions(structInfo, writer);
            token.ThrowIfCancellationRequested();
        }
        
        // write static address method bodies
        if (!structInfo.StaticAddresses.IsEmpty) {
            RenderStaticAddresses(structInfo, writer);
            token.ThrowIfCancellationRequested();
        }
        
        // write closing struct hierarchy
        for (var i = 0; i < structInfo.Hierarchy.Length; i++) {
            writer.DecreaseIndent();
            writer.WriteLine("}");
        }

        return writer.ToString();
    }

    private static void RenderAddresses(StructInfo structInfo, IndentedTextWriter writer) {
        writer.WriteLine("public static class Addresses");
        using (writer.WriteBlock()) {
            foreach (MemberFunctionInfo mfi in structInfo.MemberFunctions) {
                writer.WriteLine(GetAddressString(structInfo, mfi.MethodInfo, mfi.SignatureInfo));
            }
            foreach (StaticAddressInfo sai in structInfo.StaticAddresses) {
                writer.WriteLine(GetAddressString(structInfo, sai.MethodInfo, sai.SignatureInfo));
            }
        }
    }

    private static string GetAddressString(StructInfo structInfo, MethodInfo methodInfo, SignatureInfo signatureInfo) {
        string paddedSignature = signatureInfo.GetPaddedSignature();
        int adjustedOffset = signatureInfo.GetRelCallAndJumpAdjustedOffset();

        // get signature as ulong array
        IEnumerable<string> groupedSig = paddedSignature.Replace("??", "00").Split()
            .Select((x, i) => new { Index = i, Value = x })
            .GroupBy(x => x.Index / 8 * 3)
            .Select(x => x.Select(v => v.Value))
            .Select(x => "0x" + string.Join(string.Empty, x.Reverse()));

        string ulongArraySignature = "new ulong[] {" + string.Join(", ", groupedSig) + "}";

        // get signature mask as ulong array
        IEnumerable<string> groupedSigMask = paddedSignature.Split()
            .Select(s => s == "??" ? "00" : "FF")
            .Select((x, i) => new { Index = i, Value = x })
            .GroupBy(x => x.Index / 8 * 3)
            .Select(x => x.Select(v => v.Value))
            .Select(x => "0x" + string.Join(string.Empty, x.Reverse()));

        string ulongArrayMask = "new ulong[] {" + string.Join(", ", groupedSigMask) + "}";

        return $"""public static readonly Address {methodInfo.Name} = new Address("{structInfo.FullyQualifiedMetadataName}.{methodInfo.Name}", "{paddedSignature}", {adjustedOffset}, {ulongArraySignature}, {ulongArrayMask}, 0);""";
    }

    private static void RenderVirtualTable(StructInfo structInfo, IndentedTextWriter writer) {
        writer.WriteLine("[StructLayout(LayoutKind.Explicit)]");
        writer.WriteLine($"public unsafe partial struct {structInfo.Name}VirtualTable");
        using (writer.WriteBlock()) {
            foreach (VirtualFunctionInfo vfi in structInfo.VirtualFunctions) {
                var functionPointerType = $"delegate* unmanaged[Stdcall] <{structInfo.Name}*, {vfi.MethodInfo.GetParameterTypeString()}{vfi.MethodInfo.ReturnType}>";
                writer.WriteLine($"[FieldOffset({vfi.Index * 8})] public {functionPointerType} {vfi.MethodInfo.Name};");
            }
        }
        writer.WriteLine($"[FieldOffset(0)] public {structInfo.Name}VirtualTable* VirtualTable;");
    }

    private static void RenderMemberFunctions(StructInfo structInfo, IndentedTextWriter writer) {
        // pointers to functions
        writer.WriteLine("public unsafe static class MemberFunctionPointers");
        using (writer.WriteBlock()) {
            foreach (MemberFunctionInfo mfi in structInfo.MemberFunctions) {
                // add struct type as first argument if method is not static
                string thisPtrType = mfi.MethodInfo.IsStatic ? string.Empty : $"{structInfo.Name}*, ";
                var functionPointerType = $"delegate* unmanaged[Stdcall] <{thisPtrType}{mfi.MethodInfo.GetParameterTypeString()}{mfi.MethodInfo.ReturnType}>";
                writer.WriteLine($"public static {functionPointerType} {mfi.MethodInfo.Name} => ({functionPointerType}) {structInfo.Name}.Addresses.{mfi.MethodInfo.Name}.Value;");
            }
        }
        foreach (MemberFunctionInfo mfi in structInfo.MemberFunctions) {
            writer.WriteLine(mfi.MethodInfo.GetDeclarationString());
            using (writer.WriteBlock()) {
                writer.WriteLine($"if (MemberFunctionPointers.{mfi.MethodInfo.Name} is null)");
                using (writer.WriteBlock()) {
                    writer.WriteLine($"""throw new InvalidOperationException("Function pointer for {structInfo.Name}.{mfi.MethodInfo.Name} is null. The resolver was either uninitialized or failed to resolve address with signature {mfi.SignatureInfo.Signature}.");""");
                }
                if (mfi.MethodInfo.IsStatic) {
                    writer.WriteLine($"{mfi.MethodInfo.GetReturnString()}MemberFunctionPointers.{mfi.MethodInfo.Name}({mfi.MethodInfo.GetParameterNamesString()});");
                } else {
                    var paramNames = String.Empty;
                    if (mfi.MethodInfo.Parameters.Any())
                        paramNames = ", " + mfi.MethodInfo.GetParameterNamesString();
                    writer.WriteLine($"{mfi.MethodInfo.GetReturnString()}MemberFunctionPointers.{mfi.MethodInfo.Name}(({structInfo.Name}*)Unsafe.AsPointer(ref this){paramNames});");
                }
            }
        }
    }

    private static void RenderVirtualFunctions(StructInfo structInfo, IndentedTextWriter writer) {
        foreach (VirtualFunctionInfo vfi in structInfo.VirtualFunctions) {
            writer.WriteLine(vfi.MethodInfo.GetDeclarationString());
            using (writer.WriteBlock()) {
                var paramNames = String.Empty;
                if (vfi.MethodInfo.Parameters.Any())
                    paramNames = ", " + vfi.MethodInfo.GetParameterNamesString();
                writer.WriteLine($"{vfi.MethodInfo.GetReturnString()}VirtualTable->{vfi.MethodInfo.Name}(({structInfo.Name}*)Unsafe.AsPointer(ref this){paramNames});");
            }
        }
    }

    private static void RenderStaticAddresses(StructInfo structInfo, IndentedTextWriter writer) {
        // pointers to static addresses
        writer.WriteLine("public unsafe static class StaticAddressPointers");
        using (writer.WriteBlock()) {
            foreach (StaticAddressInfo sai in structInfo.StaticAddresses) {
                string pointerText = sai.IsPointer ? "* p" : " ";
                string pointer = sai.IsPointer ? "*" : string.Empty;
                writer.WriteLine($"public static {sai.MethodInfo.ReturnType}{pointerText}p{sai.MethodInfo.Name} => ({sai.MethodInfo.ReturnType}{pointer}){structInfo.Name}.Addresses.{sai.MethodInfo.Name}.Value;");
            }
        }
        foreach (StaticAddressInfo sai in structInfo.StaticAddresses) {
            writer.WriteLine(sai.MethodInfo.GetDeclarationString());
            string extraPointerText = sai.IsPointer ? "p" : string.Empty;
            string pointerReturnText = sai.IsPointer ? "*" : string.Empty;

            using (writer.WriteBlock()) {
                writer.WriteLine($"if (StaticAddressPointers.{extraPointerText}p{sai.MethodInfo.Name} is null)");
                using (writer.WriteBlock()) {
                    writer.WriteLine($"""throw new InvalidOperationException("Static address pointer for {structInfo.Name}.{sai.MethodInfo.Name} is null. The resolver was either uninitialized or failed to resolve address with signature {sai.SignatureInfo.Signature}.");""");
                }
                writer.WriteLine($"return {pointerReturnText}StaticAddressPointers.{extraPointerText}p{sai.MethodInfo.Name};");
            }
        }
    }
    private static string RenderResolverInitializer(ImmutableArray<StructInfo> structInfos, string interopNamespace) {
        using IndentedTextWriter writer = new();
        // write file header
        writer.WriteLine("// <auto-generated/>");
        writer.WriteLine($"namespace {interopNamespace};");
        writer.WriteLine("public static class Interop");
        using (writer.WriteBlock()) {
            writer.WriteLine("public static void InitializeAddresses()");
            using (writer.WriteBlock()) {
                foreach (StructInfo sInfo in structInfos) {
                    // member function addresses
                    foreach (MemberFunctionInfo mfi in sInfo.MemberFunctions) {
                        writer.WriteLine(GetAddToResolverString(sInfo, mfi.MethodInfo));
                    }
                    // static addresses
                    foreach (StaticAddressInfo sai in sInfo.StaticAddresses) {
                        writer.WriteLine(GetAddToResolverString(sInfo, sai.MethodInfo));
                    }
                }
            }
        }

        return writer.ToString();
    }

    private static string GetAddToResolverString(StructInfo structInfo, MethodInfo methodInfo) {
        string namespaceString = string.IsNullOrEmpty(structInfo.Namespace) ? string.Empty : structInfo.Namespace + ".";
        var fullTypeName = $"global::{namespaceString}{string.Join(".", structInfo.Hierarchy.Reverse())}";
        return $"InteropGenerator.Runtime.Resolver.GetInstance.RegisterAddress({fullTypeName}.Addresses.{methodInfo.Name});";
    }
}
