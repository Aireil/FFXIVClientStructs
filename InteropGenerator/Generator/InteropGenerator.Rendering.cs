using System.Collections.Immutable;
using InteropGenerator.Helpers;
using InteropGenerator.Models;

namespace InteropGenerator.Generator;

public sealed partial class InteropGenerator {
    private static string RenderStructInfo(StructInfo structInfo) {
        using IndentedTextWriter writer = new();
        // write file header
        writer.WriteLine("// <auto-generated/>");

        // write namespace 
        if (structInfo.Namespace.Length > 0) {
            writer.WriteLine($"namespace {structInfo.Namespace};");
            writer.WriteLine();
        }

        // write opening struct hierarchy in reverse order
        // note we do not need to specify the accessibility here since a partial declared with no accessibility uses the other partial
        for (int i = structInfo.Hierarchy.Length - 1; i >= 0; i--) {
            writer.WriteLine($"unsafe partial struct {structInfo.Hierarchy[i]}");
            writer.WriteLine("{");
            writer.IncreaseIndent();
        }
        
        // write addresses for resolver
        if (structInfo.HasSignatures())
            RenderAddresses(structInfo, writer);
        
        // write member function pointers & method bodies
        if (!structInfo.MemberFunctions.IsEmpty)
            RenderMemberFunctions(structInfo, writer);
        
        // write static address method bodies
        if (!structInfo.StaticAddresses.IsEmpty)
            RenderStaticAddresses(structInfo, writer);

        // write closing struct hierarchy
        for (var i = 0; i < structInfo.Hierarchy.Length; i++) {
            writer.DecreaseIndent();
            writer.WriteLine("}");
        }

        return writer.ToString();
    }

    private static void RenderAddresses(StructInfo structInfo, IndentedTextWriter writer) {
        writer.WriteLine("public static class Addresses");
        using (writer.WriteBlock()) {
            foreach(MemberFunctionInfo mfi in structInfo.MemberFunctions)
                writer.WriteLine(GetAddressString(structInfo, mfi.MethodInfo, mfi.Signature, mfi.Offset));
            foreach(StaticAddressInfo sai in structInfo.StaticAddresses)
                writer.WriteLine(GetAddressString(structInfo, sai.MethodInfo, sai.Signature, sai.Offset));
        }
    }

    private static string GetAddressString(StructInfo structInfo, MethodInfo methodInfo, string signature, byte offset) {
        // create padded signature
        int paddingNeeded = 8 - (signature.Length / 3 + 1) % 8;
        if (paddingNeeded != 0) {
            Span<char> result = new Span<char>(new char[signature.Length + paddingNeeded * 3]);
            signature.AsSpan().CopyTo(result);

            ReadOnlySpan<char> repeated = " ??".AsSpan();

            for (int repeatIndex = 0; repeatIndex < paddingNeeded; repeatIndex++) {
                repeated.CopyTo(result.Slice(signature.Length + repeatIndex * repeated.Length));
            }

            signature = result.ToString();
        }
        
        // get signature as ulong array
        IEnumerable<string> groupedSig = signature.Replace("??", "00").Split()
            .Select((x, i) => new { Index = i, Value = x })
            .GroupBy(x => x.Index / 8 * 3)
            .Select(x => x.Select(v => v.Value))
            .Select(x => "0x" + string.Join(string.Empty, x.Reverse()));

        string ulongArraySignature = "new ulong[] {" + string.Join(", ", groupedSig) + "}";
        
        // get signature mask as ulong array
        IEnumerable<string> groupedSigMask = signature.Split()
            .Select(s => s == "??" ? "00" : "FF")
            .Select((x, i) => new { Index = i, Value = x })
            .GroupBy(x => x.Index / 8 * 3)
            .Select(x => x.Select(v => v.Value))
            .Select(x => "0x" + string.Join(string.Empty, x.Reverse()));

        string ulongArrayMask = "new ulong[] {" + string.Join(", ", groupedSigMask) + "}";
        
        // handle E8 and E9 jumps automatically
        if (offset == 0 &&
            signature.StartsWith("E8") ||
            signature.StartsWith("E9"))
            offset = 1;

        return $"""public static readonly Address {methodInfo.Name} = new Address("{structInfo.FullyQualifiedMetadataName}.{methodInfo.Name}", "{signature}", {offset}, {ulongArraySignature}, {ulongArrayMask}, 0);""";
    }

    private static void RenderMemberFunctions(StructInfo structInfo, IndentedTextWriter writer) {
        // pointers to functions
        writer.WriteLine("public unsafe static class MemberFunctionPointers");
        using (writer.WriteBlock()) {
            foreach (MemberFunctionInfo mfi in structInfo.MemberFunctions) {
                // add struct type as first argument if method is not static
                string thisPtrType = mfi.MethodInfo.IsStatic ? string.Empty : $"{structInfo.Name}*, ";
                var functionPointerType = $"delegate* unmanaged[Stdcall] <{thisPtrType}{mfi.MethodInfo.GetParameterTypeString()}{mfi.MethodInfo.ReturnType}>";
                writer.WriteLine($"public static {functionPointerType} {mfi.MethodInfo.Name} => ({functionPointerType}) {structInfo.Name}.Addresses.{mfi.MethodInfo.Name}.Value;");
            }
        }
        foreach (MemberFunctionInfo mfi in structInfo.MemberFunctions) {
            writer.WriteLine(mfi.MethodInfo.GetDeclarationString());
            using (writer.WriteBlock()) {
                writer.WriteLine($"if (MemberFunctionPointers.{mfi.MethodInfo.Name} is null)");
                using (writer.WriteBlock()) {
                    writer.WriteLine($"""throw new InvalidOperationException("Function pointer for {structInfo.Name}.{mfi.MethodInfo.Name} is null. The resolver was either uninitialized or failed to resolve address with signature {mfi.Signature}.");""");
                }
                if (mfi.MethodInfo.IsStatic) {
                    writer.WriteLine($"{mfi.MethodInfo.GetReturnString()}MemberFunctionPointers.{mfi.MethodInfo.Name}({mfi.MethodInfo.GetParameterNamesString()});");
                } else {
                    var paramNames = "";
                    if (mfi.MethodInfo.Parameters.Any())
                        paramNames = ", " + mfi.MethodInfo.GetParameterNamesString();
                    writer.WriteLine($"{mfi.MethodInfo.GetReturnString()}MemberFunctionPointers.{mfi.MethodInfo.Name}(({structInfo.Name}*)Unsafe.AsPointer(ref this){paramNames});");
                }
            }
        }
    }

    private static void RenderStaticAddresses(StructInfo structInfo, IndentedTextWriter writer) {
        // pointers to static addresses
        writer.WriteLine("public unsafe static class StaticAddressPointers");
        using (writer.WriteBlock()) {
            foreach (StaticAddressInfo sai in structInfo.StaticAddresses) {
                string pointerText = sai.IsPointer ? "* p" : " ";
                string pointer = sai.IsPointer ? "*" : string.Empty;
                writer.WriteLine($"public static {sai.MethodInfo.ReturnType}{pointerText}p{sai.MethodInfo.Name} => ({sai.MethodInfo.ReturnType}{pointer}){structInfo.Name}.Addresses.{sai.MethodInfo.Name}.Value;");
            }
        }
        foreach (StaticAddressInfo sai in structInfo.StaticAddresses) {
            writer.WriteLine(sai.MethodInfo.GetDeclarationString());
            string extraPointerText = sai.IsPointer ? "p" : string.Empty;
            string pointerReturnText = sai.IsPointer ? "*" : string.Empty;

            using (writer.WriteBlock()) {
                writer.WriteLine($"if (StaticAddressPointers.{extraPointerText}p{sai.MethodInfo.Name} is null)");
                using (writer.WriteBlock()) {
                    writer.WriteLine($"""throw new InvalidOperationException("Static address pointer for {structInfo.Name}.{sai.MethodInfo.Name} is null. The resolver was either uninitialized or failed to resolve address with signature {sai.Signature}.");""");
                }
                writer.WriteLine($"return {pointerReturnText}StaticAddressPointers.{extraPointerText}p{sai.MethodInfo.Name};");
            }
        }
    }
    private static string RenderResolverInitializer(ImmutableArray<StructInfo> structInfos, string interopNamespace) {
        using IndentedTextWriter writer = new();
        // write file header
        writer.WriteLine("// <auto-generated/>");
        writer.WriteLine($"namespace {interopNamespace};");
        writer.WriteLine("public static class Interop");
        using (writer.WriteBlock()) {
            writer.WriteLine("public static void InitializeAddresses()");
            using (writer.WriteBlock()) {
                foreach (StructInfo sInfo in structInfos) {
                    // member function addresses
                    foreach (MemberFunctionInfo mfi in sInfo.MemberFunctions) {
                        writer.WriteLine(GetAddToResolverString(sInfo, mfi.MethodInfo));
                    }
                    // static addresses
                    foreach (StaticAddressInfo sai in sInfo.StaticAddresses) {
                        writer.WriteLine(GetAddToResolverString(sInfo, sai.MethodInfo));
                    }
                }
            }
        }
        
        return writer.ToString();
    }

    private static string GetAddToResolverString(StructInfo structInfo, MethodInfo methodInfo) {
        string namespaceString = string.IsNullOrEmpty(structInfo.Namespace) ? string.Empty : structInfo.Namespace + ".";
        var fullTypeName = $"global::{namespaceString}{string.Join(".", structInfo.Hierarchy.Reverse())}";
        return $"InteropGenerator.Runtime.Resolver.GetInstance.RegisterAddress({fullTypeName}.Addresses.{methodInfo.Name});";
    }
}
