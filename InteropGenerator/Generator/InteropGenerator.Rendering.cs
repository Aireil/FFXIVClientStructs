using InteropGenerator.Helpers;
using InteropGenerator.Models;

namespace InteropGenerator.Generator;

public sealed partial class InteropGenerator {
    private static string RenderStructInfo(StructInfo structInfo) {
        using IndentedTextWriter writer = new();
        // write file header
        writer.WriteLine("// <auto-generated/>");

        // write namespace 
        if (structInfo.Namespace.Length > 0) {
            writer.WriteLine($"namespace {structInfo.Namespace};");
            writer.WriteLine();
        }

        // write opening struct hierarchy in reverse order
        // note we do not need to specify the accessibility here since a partial declared with no accessibility uses the other partial
        for (int i = structInfo.Hierarchy.Length - 1; i >= 0; i--) {
            writer.WriteLine($"unsafe partial struct {structInfo.Hierarchy[i]}");
            writer.WriteLine("{");
            writer.IncreaseIndent();
        }
        
        // write addresses for resolver
        if (structInfo.HasSignatures())
            RenderAddresses(structInfo, writer);
        
        // write member function pointers & method bodies
        if (!structInfo.MemberFunctions.IsEmpty)
            RenderMemberFunctions(structInfo, writer);

        // write closing struct hierarchy
        for (var i = 0; i < structInfo.Hierarchy.Length; i++) {
            writer.DecreaseIndent();
            writer.WriteLine("}");
        }

        return writer.ToString();
    }

    private static void RenderAddresses(StructInfo structInfo, IndentedTextWriter writer) {
        writer.WriteLine("public static class Addresses");
        using (writer.WriteBlock()) {
            foreach(MemberFunctionInfo mfi in structInfo.MemberFunctions)
                writer.WriteLine(GetAddressString(structInfo, mfi.MethodInfo, mfi.Signature));
        }
    }

    private static string GetAddressString(StructInfo structInfo, MethodInfo methodInfo, string signature) {
        // create padded signature
        int paddingNeeded = 8 - (signature.Length / 3 + 1) % 8;
        if (paddingNeeded != 0) {
            Span<char> result = new Span<char>(new char[signature.Length + paddingNeeded * 3]);
            signature.AsSpan().CopyTo(result);

            ReadOnlySpan<char> repeated = " ??".AsSpan();

            for (int repeatIndex = 0; repeatIndex < paddingNeeded; repeatIndex++) {
                repeated.CopyTo(result.Slice(signature.Length + repeatIndex * repeated.Length));
            }

            signature = result.ToString();
        }
        
        // get signature as ulong array
        IEnumerable<string> groupedSig = signature.Replace("??", "00").Split()
            .Select((x, i) => new { Index = i, Value = x })
            .GroupBy(x => x.Index / 8 * 3)
            .Select(x => x.Select(v => v.Value))
            .Select(x => "0x" + string.Join(string.Empty, x.Reverse()));

        string ulongArraySignature = "new ulong[] {" + string.Join(", ", groupedSig) + "}";
        
        // get signature mask as ulong array
        IEnumerable<string> groupedSigMask = signature.Split()
            .Select(s => s == "??" ? "00" : "FF")
            .Select((x, i) => new { Index = i, Value = x })
            .GroupBy(x => x.Index / 8 * 3)
            .Select(x => x.Select(v => v.Value))
            .Select(x => "0x" + string.Join(string.Empty, x.Reverse()));

        string ulongArrayMask = "new ulong[] {" + string.Join(", ", groupedSigMask) + "}";

        return $"""public static readonly Address {methodInfo.Name} = new Address("{structInfo.FullyQualifiedMetadataName}.{methodInfo.Name}", "{signature}", {ulongArraySignature}, {ulongArrayMask}, 0);""";
    }

    private static void RenderMemberFunctions(StructInfo structInfo, IndentedTextWriter writer) {
        // pointers to functions
        writer.WriteLine("public unsafe static class MemberFunctionPointers");
        using (writer.WriteBlock()) {
            foreach (MemberFunctionInfo mfi in structInfo.MemberFunctions) {
                // add struct type as first argument if method is not static
                string thisPtrType = mfi.MethodInfo.IsStatic ? "" : $"{structInfo.Name}*, ";
                var functionPointerType = $"delegate* unmanaged[Stdcall] <{thisPtrType}{mfi.MethodInfo.GetParameterTypeString()}{mfi.MethodInfo.ReturnType}>";
                writer.WriteLine($"public static {functionPointerType} {mfi.MethodInfo.Name} => ({functionPointerType}) {structInfo.Name}.Addresses.{mfi.MethodInfo.Name}.Value;");
            }
        }
        foreach (MemberFunctionInfo mfi in structInfo.MemberFunctions) {
            writer.WriteLine(mfi.MethodInfo.GetDeclarationString());
            using (writer.WriteBlock()) {
                writer.WriteLine($"if (MemberFunctionPointers.{mfi.MethodInfo.Name} is null)");
                using (writer.WriteBlock()) {
                    writer.WriteLine($"""throw new InvalidOperationException("Function pointer for {structInfo.Name}.{mfi.MethodInfo.Name} is null. The resolver was either uninitialized or failed to resolve address with signature {mfi.Signature}.");""");
                }
                if (mfi.MethodInfo.IsStatic) {
                    writer.WriteLine($"{mfi.MethodInfo.GetReturnString()}MemberFunctionPointers.{mfi.MethodInfo.Name}({mfi.MethodInfo.GetParameterNamesString()});");
                } else {
                    var paramNames = "";
                    if (mfi.MethodInfo.Parameters.Any())
                        paramNames = ", " + mfi.MethodInfo.GetParameterNamesString();
                    writer.WriteLine($"{mfi.MethodInfo.GetReturnString()}MemberFunctionPointers.{mfi.MethodInfo.Name}(({structInfo.Name}*)Unsafe.AsPointer(ref this){paramNames});");
                }
            }
        }
    }
}
