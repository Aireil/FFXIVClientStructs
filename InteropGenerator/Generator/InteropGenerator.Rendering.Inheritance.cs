using System.Collections.Immutable;
using InteropGenerator.Helpers;
using InteropGenerator.Models;

namespace InteropGenerator.Generator;

public sealed partial class InteropGenerator {
    private static string RenderInheritedStructInfo(StructInfo structInfo, ImmutableArray<StructInfo> inheritedStructs, CancellationToken token) {
        using IndentedTextWriter writer = new();

        // write file header
        writer.WriteLine("// <auto-generated/>");

        // write namespace 
        if (structInfo.Namespace.Length > 0) {
            writer.WriteLine($"namespace {structInfo.Namespace};");
            writer.WriteLine();
        }

        // write opening struct hierarchy in reverse order
        // note we do not need to specify the accessibility here since a partial declared with no accessibility uses the other partial
        for (int i = structInfo.Hierarchy.Length - 1; i >= 0; i--) {
            writer.WriteLine($"unsafe partial struct {structInfo.Hierarchy[i]}");
            writer.WriteLine("{");
            writer.IncreaseIndent();
        }

        if (inheritedStructs.Any())
            RenderInheritance(structInfo, inheritedStructs, token, writer);

        // write closing struct hierarchy
        for (var i = 0; i < structInfo.Hierarchy.Length; i++) {
            writer.DecreaseIndent();
            writer.WriteLine("}");
        }

        return writer.ToString();
    }
    private static void RenderInheritance(StructInfo structInfo, ImmutableArray<StructInfo> inheritedStructs, CancellationToken token, IndentedTextWriter writer) {
        // resolve the list of inherited structs and their offsets
        using ImmutableArrayBuilder<(StructInfo inheritedStruct, string path, int offset)> resolvedInheritanceOrderBuilder = new();

        var hasPrimaryVirtualFunctions = false;

        ResolveInheritanceOrder(structInfo, string.Empty, 0, 0, inheritedStructs, resolvedInheritanceOrderBuilder, ref hasPrimaryVirtualFunctions);

        ImmutableArray<(StructInfo inheritedStruct, string path, int offset)> resolvedInheritanceOrder = resolvedInheritanceOrderBuilder.ToImmutable();

        token.ThrowIfCancellationRequested();

        // inherited fields
        foreach ((StructInfo inheritedStruct, _, int offset) in resolvedInheritanceOrder) {
            // write parent accessor if its directly inherited
            if (structInfo.InheritedStructs.Any(inheritanceInfo => inheritanceInfo.InheritedTypeName == inheritedStruct.FullyQualifiedMetadataName)) {
                writer.WriteLine($"""/// <summary>Inherited parent class accessor for <see cref="{inheritedStruct.FullyQualifiedMetadataName}">{inheritedStruct.Name}</see></summary>""");
                writer.WriteLine($"[FieldOffset({offset})] public {inheritedStruct.FullyQualifiedMetadataName} {inheritedStruct.Name};");
            }
            // write public fields
            foreach (FieldInfo field in inheritedStruct.ExtraInheritedStructInfo!.PublicFields) {
                writer.WriteLine($"""/// <inheritdoc cref="{inheritedStruct.FullyQualifiedMetadataName}.{field.Name}" />""");
                writer.WriteLine($"""/// <remarks>Field inherited from parent class <see cref="{inheritedStruct.FullyQualifiedMetadataName}">{inheritedStruct.Name}</see>.</remarks>""");
                writer.WriteLine($"[FieldOffset({offset + field.Offset})] public {field.Type} {field.Name};");
            }
        }

        token.ThrowIfCancellationRequested();

        // inherited member functions
        foreach ((StructInfo inheritedStruct, string path, _) in resolvedInheritanceOrder) {
            if (!inheritedStruct.MemberFunctions.IsEmpty)
                RenderInheritedMemberFunctions(inheritedStruct, path, writer);
        }

        token.ThrowIfCancellationRequested();

        // add entries to the main virtual table for the primary inheritance chain
        if (hasPrimaryVirtualFunctions)
            RenderInheritedVirtualTable(structInfo, resolvedInheritanceOrder, writer);

        // inherited virtual function bodies
        foreach ((StructInfo inheritedStruct, string path, int offset) in resolvedInheritanceOrder) {
            if (!inheritedStruct.VirtualFunctions.IsEmpty)
                RenderInheritedVirtualFunctions(structInfo.Name, inheritedStruct, path, offset, writer);
        }

        token.ThrowIfCancellationRequested();

        // inherited public methods
        foreach ((StructInfo inheritedStruct, string path, _) in resolvedInheritanceOrder) {
            if (!inheritedStruct.ExtraInheritedStructInfo!.PublicMethods.IsEmpty)
                RenderInheritedPublicMethods(inheritedStruct, path, writer);
        }

        token.ThrowIfCancellationRequested();

        // inherited string overloads
        // we can just use the regular renderer here since the overloaded function should also be inherited
        foreach ((StructInfo inheritedStruct, _, _) in resolvedInheritanceOrder) {
            if (!inheritedStruct.StringOverloads.IsEmpty)
                RenderStringOverloads(inheritedStruct, writer);
        }
        
        token.ThrowIfCancellationRequested();

        // inherited fixed array accessors
        foreach ((StructInfo inheritedStruct, string path, _) in resolvedInheritanceOrder) {
            if (!inheritedStruct.FixedSizeArrays.IsEmpty)
                RenderInheritedFixedSizeArrayAccessors(inheritedStruct, path, writer);
        }
        
        token.ThrowIfCancellationRequested();
    }

    private static int ResolveInheritanceOrder(StructInfo structInfo, string path, int offset, int index, ImmutableArray<StructInfo> inheritedStructs, ImmutableArrayBuilder<(StructInfo inheritedStruct, string path, int offset)> resolvedInheritanceOrder, ref bool hasPrimaryVirtualFunctions) {
        var processed = 0;
        foreach (InheritanceInfo inheritanceInfo in structInfo.InheritedStructs) {
            // failure earlier in generator, haven't collected all inherited structs
            if (index >= inheritedStructs.Length) {
                return 0;
            }

            if (inheritanceInfo.ParentOffset != 0)
                offset = inheritanceInfo.ParentOffset;

            StructInfo currentStruct = inheritedStructs[index + processed];
            string newPath = path == string.Empty ? currentStruct.Name : path + "." + currentStruct.Name;

            processed += 1;

            processed += ResolveInheritanceOrder(currentStruct, newPath, offset, index + processed, inheritedStructs, resolvedInheritanceOrder, ref hasPrimaryVirtualFunctions);

            resolvedInheritanceOrder.Add((currentStruct, newPath, offset));
            if (offset == 0 && !currentStruct.VirtualFunctions.IsEmpty)
                hasPrimaryVirtualFunctions = true;

            offset += currentStruct.ExtraInheritedStructInfo!.Size;
        }
        return processed;
    }

    private static void RenderInheritedMemberFunctions(StructInfo inheritedStruct, string path, IndentedTextWriter writer) {
        foreach (MemberFunctionInfo memberFunctionInfo in inheritedStruct.MemberFunctions) {
            MethodInfo methodInfo = memberFunctionInfo.MethodInfo;
            writer.WriteLine($"""/// <inheritdoc cref="{inheritedStruct.FullyQualifiedMetadataName}.{methodInfo.Name}" />""");
            writer.WriteLine($"""/// <remarks>Method inherited from parent class <see cref="{inheritedStruct.FullyQualifiedMetadataName}">{inheritedStruct.Name}</see>.</remarks>""");
            writer.WriteLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            // public int SomeInheritedMethod(int param, int param2) => Path.To.Parent.SomeInheritedMethod(param, param2);
            writer.WriteLine($"{methodInfo.GetDeclarationStringWithoutPartial()} => {path}.{methodInfo.Name}({methodInfo.GetParameterNamesString()});");
        }
    }

    private static void RenderInheritedVirtualTable(StructInfo structInfo, ImmutableArray<(StructInfo inheritedStruct, string path, int offset)> resolvedInheritanceOrder, IndentedTextWriter writer) {
        // write virtual function pointers from inherited structs using the child struct type as the "this" pointer
        // StructLayout can't be duplicated so only write it if it hasnt been written before
        if (!structInfo.HasVirtualTable())
            writer.WriteLine("[StructLayout(LayoutKind.Explicit)]");
        writer.WriteLine($"public unsafe partial struct {structInfo.Name}VirtualTable");
        using (writer.WriteBlock()) {
            foreach ((StructInfo inheritedStruct, _, int offset) in resolvedInheritanceOrder) {
                // only inherited structs at offset 0 are the primary inheritance chain that make up the main virtual table
                if (offset != 0)
                    continue;
                foreach (VirtualFunctionInfo virtualFunctionInfo in inheritedStruct.VirtualFunctions) {
                    var functionPointerType = $"delegate* unmanaged[Stdcall] <{structInfo.Name}*, {virtualFunctionInfo.MethodInfo.GetParameterTypeString()}{virtualFunctionInfo.MethodInfo.ReturnType}>";
                    writer.WriteLine($"[FieldOffset({virtualFunctionInfo.Index * 8})] public {functionPointerType} {virtualFunctionInfo.MethodInfo.Name};");
                }
            }
        }
        // if the only virtual functions were inherited we need to write the vtable accessor
        if (!structInfo.HasVirtualTable()) {
            writer.WriteLine($"[FieldOffset(0)] public {structInfo.Name}VirtualTable* VirtualTable;");
        }
    }

    private static void RenderInheritedVirtualFunctions(string childTypeName, StructInfo inheritedStruct, string path, int offset, IndentedTextWriter writer) {
        foreach (VirtualFunctionInfo virtualFunctionInfo in inheritedStruct.VirtualFunctions) {
            MethodInfo methodInfo = virtualFunctionInfo.MethodInfo;
            writer.WriteLine($"""/// <inheritdoc cref="{inheritedStruct.FullyQualifiedMetadataName}.{methodInfo.Name}" />""");
            writer.WriteLine($"""/// <remarks>Method inherited from parent class <see cref="{inheritedStruct.FullyQualifiedMetadataName}">{inheritedStruct.Name}</see>.</remarks>""");
            writer.WriteLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            // function in table - call via table
            if (offset == 0) {
                var paramNames = string.Empty;
                if (methodInfo.Parameters.Any())
                    paramNames = ", " + methodInfo.GetParameterNamesString();
                writer.WriteLine($"{methodInfo.GetDeclarationStringWithoutPartial()} => VirtualTable->{methodInfo.Name}(({childTypeName}*)Unsafe.AsPointer(ref this){paramNames});");
            } else {
                writer.WriteLine($"{methodInfo.GetDeclarationStringWithoutPartial()} => {path}.{methodInfo.Name}({methodInfo.GetParameterNamesString()});");
            }
        }
    }
    
    private static void RenderInheritedPublicMethods(StructInfo inheritedStruct, string path, IndentedTextWriter writer) {
        foreach (MethodInfo methodInfo in inheritedStruct.ExtraInheritedStructInfo!.PublicMethods) {
            writer.WriteLine($"""/// <inheritdoc cref="{inheritedStruct.FullyQualifiedMetadataName}.{methodInfo.Name}" />""");
            writer.WriteLine($"""/// <remarks>Method inherited from parent class <see cref="{inheritedStruct.FullyQualifiedMetadataName}">{inheritedStruct.Name}</see>.</remarks>""");
            writer.WriteLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            // public int SomeInheritedMethod(int param, int param2) => Path.To.Parent.SomeInheritedMethod(param, param2);
            writer.WriteLine($"{methodInfo.GetDeclarationStringWithoutPartial()} => {path}.{methodInfo.Name}({methodInfo.GetParameterNamesString()});");
        }
    }
    
    private static void RenderInheritedFixedSizeArrayAccessors(StructInfo inheritedStruct, string path, IndentedTextWriter writer) {
        foreach (FixedSizeArrayInfo fixedSizeArrayInfo in inheritedStruct.FixedSizeArrays) {
            writer.WriteLine($"""/// <inheritdoc cref="{inheritedStruct.FullyQualifiedMetadataName}.{fixedSizeArrayInfo.GetPublicFieldName()}" />""");
            writer.WriteLine($"""/// <remarks>Field inherited from parent class <see cref="{inheritedStruct.FullyQualifiedMetadataName}">{inheritedStruct.Name}</see>.</remarks>""");
            // [UnscopedRef] public Span<T> FieldName => Path.To.Parent_fieldName;
            writer.WriteLine($"[UnscopedRef] public Span<{fixedSizeArrayInfo.Type}> {fixedSizeArrayInfo.GetPublicFieldName()} => {path}.{fixedSizeArrayInfo.FieldName};");
        }
    }
}
