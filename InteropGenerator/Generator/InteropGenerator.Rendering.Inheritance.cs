using System.Collections.Immutable;
using InteropGenerator.Helpers;
using InteropGenerator.Models;

namespace InteropGenerator.Generator;

public sealed partial class InteropGenerator {
    private static string RenderInheritedStructInfo(StructInfo structInfo, ImmutableArray<StructInfo> inheritedStructs, CancellationToken token) {
        using IndentedTextWriter writer = new();
        
        // write file header
        writer.WriteLine("// <auto-generated/>");

        // write namespace 
        if (structInfo.Namespace.Length > 0) {
            writer.WriteLine($"namespace {structInfo.Namespace};");
            writer.WriteLine();
        }

        // write opening struct hierarchy in reverse order
        // note we do not need to specify the accessibility here since a partial declared with no accessibility uses the other partial
        for (int i = structInfo.Hierarchy.Length - 1; i >= 0; i--) {
            writer.WriteLine($"unsafe partial struct {structInfo.Hierarchy[i]}");
            writer.WriteLine("{");
            writer.IncreaseIndent();
        }

        if (inheritedStructs.Any())
            RenderInheritance(structInfo, inheritedStructs, token, writer);
      
        // write closing struct hierarchy
        for (var i = 0; i < structInfo.Hierarchy.Length; i++) {
            writer.DecreaseIndent();
            writer.WriteLine("}");
        }

        return writer.ToString();
    }
    private static void RenderInheritance(StructInfo structInfo, ImmutableArray<StructInfo> inheritedStructs, CancellationToken token, IndentedTextWriter writer) {
        // resolve the list of inherited structs and their offsets
        using ImmutableArrayBuilder<(StructInfo inheritedStruct, int offset)> resolvedInheritanceOrder = new();

        ResolveInheritanceOrder(structInfo, 0, 0, inheritedStructs, resolvedInheritanceOrder);

        foreach (var thing in resolvedInheritanceOrder.ToImmutable()) {
            writer.WriteLine($"// {thing.inheritedStruct.Name} {thing.offset}");
        }
    }
    private static int ResolveInheritanceOrder(StructInfo structInfo, int offset, int index, ImmutableArray<StructInfo> inheritedStructs, ImmutableArrayBuilder<(StructInfo inheritedStruct, int offset)> resolvedInheritanceOrder) {
        var processed = 0;
        foreach (InheritanceInfo inheritanceInfo in structInfo.InheritedStructs) {
            // failure earlier in generator, haven't collected all inherited structs
            if (index >= inheritedStructs.Length)
                return 0;

            if (inheritanceInfo.ParentOffset != 0)
                offset = inheritanceInfo.ParentOffset;

            StructInfo currentStruct = inheritedStructs[index + processed];

            processed += 1;

            processed += ResolveInheritanceOrder(currentStruct, offset, index + processed, inheritedStructs, resolvedInheritanceOrder);
            
            resolvedInheritanceOrder.Add((currentStruct, offset));

            offset += currentStruct.ExtraInheritedStructInfo!.Size;
        }
        return processed;
    }
}
