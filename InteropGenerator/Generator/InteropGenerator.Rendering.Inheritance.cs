using System.Collections.Immutable;
using System.Runtime.InteropServices.ComTypes;
using InteropGenerator.Helpers;
using InteropGenerator.Models;

namespace InteropGenerator.Generator;

public sealed partial class InteropGenerator {
    private static string RenderInheritedStructInfo(StructInfo structInfo, ImmutableArray<StructInfo> inheritedStructs, CancellationToken token) {
        using IndentedTextWriter writer = new();
        
        // write file header
        writer.WriteLine("// <auto-generated/>");

        // write namespace 
        if (structInfo.Namespace.Length > 0) {
            writer.WriteLine($"namespace {structInfo.Namespace};");
            writer.WriteLine();
        }

        // write opening struct hierarchy in reverse order
        // note we do not need to specify the accessibility here since a partial declared with no accessibility uses the other partial
        for (int i = structInfo.Hierarchy.Length - 1; i >= 0; i--) {
            writer.WriteLine($"unsafe partial struct {structInfo.Hierarchy[i]}");
            writer.WriteLine("{");
            writer.IncreaseIndent();
        }

        if (inheritedStructs.Any())
            RenderInheritance(structInfo, inheritedStructs, token, writer);
      
        // write closing struct hierarchy
        for (var i = 0; i < structInfo.Hierarchy.Length; i++) {
            writer.DecreaseIndent();
            writer.WriteLine("}");
        }

        return writer.ToString();
    }
    private static void RenderInheritance(StructInfo structInfo, ImmutableArray<StructInfo> inheritedStructs, CancellationToken token, IndentedTextWriter writer) {
        // resolve the list of inherited structs and their offsets
        using ImmutableArrayBuilder<(StructInfo inheritedStruct, string path, int offset)> resolvedInheritanceOrderBuilder = new();

        ResolveInheritanceOrder(structInfo, string.Empty, 0, 0, inheritedStructs, resolvedInheritanceOrderBuilder);

        ImmutableArray<(StructInfo inheritedStruct, string path, int offset)> resolvedInheritanceOrder = resolvedInheritanceOrderBuilder.ToImmutable();
        
        token.ThrowIfCancellationRequested();
        
        // inherited fields
        foreach ((StructInfo inheritedStruct, _, int offset) in resolvedInheritanceOrder) {
            // write parent accessor if its directly inherited
            if (structInfo.InheritedStructs.Any(inheritanceInfo => inheritanceInfo.InheritedTypeName == inheritedStruct.FullyQualifiedMetadataName)) {
                writer.WriteLine($"""/// <summary>Inherited parent class accessor for <see cref="{inheritedStruct.FullyQualifiedMetadataName}">{inheritedStruct.Name}</see></summary>""");
                writer.WriteLine($"[FieldOffset({offset})] public {inheritedStruct.FullyQualifiedMetadataName} {inheritedStruct.Name};");
            }
            // write public fields
            foreach (FieldInfo field in inheritedStruct.ExtraInheritedStructInfo!.PublicFields) {
                writer.WriteLine($"""/// <inheritdoc cref="{inheritedStruct.FullyQualifiedMetadataName}.{field.Name}" />""");
                writer.WriteLine($"""/// <remarks>Field inherited from parent class <see cref="{inheritedStruct.FullyQualifiedMetadataName}">{inheritedStruct.Name}</see>.</remarks>""");
                writer.WriteLine($"[FieldOffset({offset + field.Offset})] public {field.Type} {field.Name};");
            }
        }
        
        token.ThrowIfCancellationRequested();
        
        // inherited member functions
        foreach ((StructInfo inheritedStruct, string path, _) in resolvedInheritanceOrder) {
            if (!inheritedStruct.MemberFunctions.IsEmpty)
                WriteInheritedMemberFunctions(inheritedStruct, path, writer);
        }
        
        token.ThrowIfCancellationRequested();
        
    }
    
    private static int ResolveInheritanceOrder(StructInfo structInfo, string path, int offset, int index, ImmutableArray<StructInfo> inheritedStructs, ImmutableArrayBuilder<(StructInfo inheritedStruct, string path, int offset)> resolvedInheritanceOrder) {
        var processed = 0;
        foreach (InheritanceInfo inheritanceInfo in structInfo.InheritedStructs) {
            // failure earlier in generator, haven't collected all inherited structs
            if (index >= inheritedStructs.Length)
                return 0;

            if (inheritanceInfo.ParentOffset != 0)
                offset = inheritanceInfo.ParentOffset;

            StructInfo currentStruct = inheritedStructs[index + processed];
            string newPath = path == string.Empty ? currentStruct.Name : path + "." +  currentStruct.Name;
            
            processed += 1;

            processed += ResolveInheritanceOrder(currentStruct, newPath, offset, index + processed, inheritedStructs, resolvedInheritanceOrder);
            
            resolvedInheritanceOrder.Add((currentStruct, newPath, offset));

            offset += currentStruct.ExtraInheritedStructInfo!.Size;
        }
        return processed;
    }

    private static void WriteInheritedMemberFunctions(StructInfo inheritedStruct, string path, IndentedTextWriter writer) {
        foreach (MemberFunctionInfo memberFunctionInfo in inheritedStruct.MemberFunctions) {
            MethodInfo methodInfo = memberFunctionInfo.MethodInfo;
            writer.WriteLine($"""/// <inheritdoc cref="{inheritedStruct.FullyQualifiedMetadataName}.{methodInfo.Name}" />""");
            writer.WriteLine($"""/// <remarks>Method inherited from parent class <see cref="{inheritedStruct.FullyQualifiedMetadataName}">{inheritedStruct.Name}</see>.</remarks>""");
            writer.WriteLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            // public int SomeInheritedMethod(int param, int param2) => Path.To.Parent.SomeInheritedMethod(param, param2);
            writer.WriteLine($"{methodInfo.GetDeclarationStringWithoutPartial()} => {path}.{methodInfo.Name}({methodInfo.GetParameterNamesString()});");
        }
    }
}
